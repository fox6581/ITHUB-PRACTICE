{"ast":null,"code":"import { createCommentVNode as _createCommentVNode, vModelText as _vModelText, createElementVNode as _createElementVNode, withDirectives as _withDirectives, withModifiers as _withModifiers, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString } from \"vue\";\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode(\"button\", {\n  type: \"submit\"\n}, \"Отправить HTTP-запрос\", -1 /* HOISTED */);\nconst _hoisted_2 = /*#__PURE__*/_createElementVNode(\"h2\", null, \"Поиск по ключам\", -1 /* HOISTED */);\nconst _hoisted_3 = /*#__PURE__*/_createElementVNode(\"h2\", null, \"Результаты HTTP-запросов:\", -1 /* HOISTED */);\nconst _hoisted_4 = /*#__PURE__*/_createElementVNode(\"h2\", null, \"WebSocket-клиент:\", -1 /* HOISTED */);\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", null, [_createCommentVNode(\" Форма для отправки HTTP-запросов \"), _createElementVNode(\"form\", {\n    onSubmit: _cache[1] || (_cache[1] = _withModifiers((...args) => $options.sendHttpRequest && $options.sendHttpRequest(...args), [\"prevent\"]))\n  }, [_withDirectives(_createElementVNode(\"input\", {\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = $event => $data.url = $event),\n    type: \"text\",\n    placeholder: \"URL\"\n  }, null, 512 /* NEED_PATCH */), [[_vModelText, $data.url]]), _hoisted_1], 32 /* HYDRATE_EVENTS */), _createCommentVNode(\" Вывод результатов HTTP-запросов \"), _createCommentVNode(\" Поиск по ключам \"), _hoisted_2, _withDirectives(_createElementVNode(\"input\", {\n    \"onUpdate:modelValue\": _cache[2] || (_cache[2] = $event => $data.searchKeyword = $event),\n    type: \"text\",\n    placeholder: \"Поиск по ключевым словам\"\n  }, null, 512 /* NEED_PATCH */), [[_vModelText, $data.searchKeyword]]), _createElementVNode(\"ul\", null, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($options.filteredKeywords, (keyword, index) => {\n    return _openBlock(), _createElementBlock(\"li\", {\n      key: index\n    }, _toDisplayString(keyword), 1 /* TEXT */);\n  }), 128 /* KEYED_FRAGMENT */))]), _createElementVNode(\"div\", null, [_hoisted_3, (_openBlock(true), _createElementBlock(_Fragment, null, _renderList($data.httpResponses, (response, index) => {\n    return _openBlock(), _createElementBlock(\"div\", {\n      key: index\n    }, [_createElementVNode(\"p\", null, _toDisplayString(response), 1 /* TEXT */)]);\n  }), 128 /* KEYED_FRAGMENT */))]), _createCommentVNode(\" WebSocket-клиент \"), _createElementVNode(\"div\", null, [_hoisted_4, _withDirectives(_createElementVNode(\"input\", {\n    \"onUpdate:modelValue\": _cache[3] || (_cache[3] = $event => $data.wsMessage = $event),\n    type: \"text\",\n    placeholder: \"WebSocket сообщение\"\n  }, null, 512 /* NEED_PATCH */), [[_vModelText, $data.wsMessage]]), _createElementVNode(\"button\", {\n    onClick: _cache[4] || (_cache[4] = (...args) => $options.sendWebSocketMessage && $options.sendWebSocketMessage(...args))\n  }, \"Отправить WebSocket сообщение\"), (_openBlock(true), _createElementBlock(_Fragment, null, _renderList($data.wsMessages, (message, index) => {\n    return _openBlock(), _createElementBlock(\"div\", {\n      key: index\n    }, [_createElementVNode(\"p\", null, _toDisplayString(message), 1 /* TEXT */)]);\n  }), 128 /* KEYED_FRAGMENT */))])]);\n}","map":{"version":3,"names":["_createElementVNode","type","_createElementBlock","_createCommentVNode","onSubmit","_cache","_withModifiers","args","$options","sendHttpRequest","$data","url","$event","placeholder","_hoisted_1","_hoisted_2","searchKeyword","_Fragment","_renderList","filteredKeywords","keyword","index","key","_toDisplayString","_hoisted_3","httpResponses","response","_hoisted_4","wsMessage","onClick","sendWebSocketMessage","wsMessages","message"],"sources":["C:\\std\\vue-nest-http-websocket\\src\\components\\HttpClient.vue"],"sourcesContent":["<template>\r\n  <div>\r\n    <!-- Форма для отправки HTTP-запросов -->\r\n    <form @submit.prevent=\"sendHttpRequest\">\r\n      <input v-model=\"url\" type=\"text\" placeholder=\"URL\">\r\n      <button type=\"submit\">Отправить HTTP-запрос</button>\r\n    </form>\r\n    <!-- Вывод результатов HTTP-запросов -->\r\n\r\n    <!-- Поиск по ключам -->\r\n    <h2>Поиск по ключам</h2>\r\n      <input v-model=\"searchKeyword\" type=\"text\" placeholder=\"Поиск по ключевым словам\">\r\n      <ul>\r\n        <li v-for=\"(keyword, index) in filteredKeywords\" :key=\"index\">{{ keyword }}</li>\r\n      </ul>\r\n    <div>\r\n\r\n\r\n      <h2>Результаты HTTP-запросов:</h2>\r\n      <div v-for=\"(response, index) in httpResponses\" :key=\"index\">\r\n        <p>{{ response }}</p>\r\n      </div>\r\n    </div>\r\n    <!-- WebSocket-клиент -->\r\n    <div>\r\n      <h2>WebSocket-клиент:</h2>\r\n      <input v-model=\"wsMessage\" type=\"text\" placeholder=\"WebSocket сообщение\">\r\n      <button @click=\"sendWebSocketMessage\">Отправить WebSocket сообщение</button>\r\n      <div v-for=\"(message, index) in wsMessages\" :key=\"index\">\r\n        <p>{{ message }}</p>\r\n\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport axios from 'axios';\r\nexport default {\r\n  data() {\r\n    return {\r\n      url: 'http://localhost:3000/api', // Замените на ваш URL сервера\r\n      httpResponses: [],\r\n      wsMessage: '',\r\n      wsMessages: [],\r\n  \r\n      socket: null, // Добавляем переменную для хранения WebSocket соединения\r\n      searchKeyword: '',\r\n      keywords: [] // Добавьте это свойство для хранения списка ключевых слов\r\n    };\r\n  },\r\n  created() {\r\n    // Инициализация WebSocket и обработчика ошибок\r\n    this.initWebSocket();\r\n    this.fetchKeywords();\r\n  },\r\n  methods: {\r\n    async sendHttpRequest() {\r\n      try {\r\n        const response = await fetch(this.url);\r\n        const data = await response.text();\r\n        this.httpResponses.push(data);\r\n      } catch (error) {\r\n        console.error(error);\r\n      }\r\n    },\r\n    async fetchKeywords() {\r\n    try {\r\n      const response = await axios.get('http://localhost:3000/keywords'); // Замените URL на свой серверный эндпоинт\r\n      console.log('Ответ от сервера:', this.response); // Вывести ответ от сервера в консоль\r\n    this.keywords = response.data;\r\n    } catch (error) {\r\n      console.error('Ошибка при получении ключевых слов:', error);\r\n    }\r\n  },\r\n    initWebSocket() {\r\n      // Инициализация WebSocket и обработчика ошибок\r\n      \r\n      const socket = new WebSocket('ws://localhost:3000/api'); \r\n\r\n      // Обработчик ошибок WebSocket\r\n      socket.addEventListener('error', (event) => {\r\n        console.error('Произошла ошибка:', event);\r\n      });\r\n\r\n      // Обработчик события открытия соединения\r\n      socket.addEventListener('open', (event) => {\r\n        console.log('WebSocket соединение установлено:', event);\r\n      });\r\n\r\n      // Обработчик события приема сообщения\r\n      socket.addEventListener('message', (event) => {\r\n        console.log('Получено сообщение:', event.data);\r\n        this.wsMessages.push(event.data); // Сохраняем полученное сообщение\r\n      });\r\n\r\n      // Обработчик события закрытия соединения\r\n      socket.addEventListener('close', (event) => {\r\n        console.log('WebSocket соединение закрыто:', event);\r\n      });\r\n    \r\n      this.socket = socket; // Сохраняем соединение в состоянии компонента\r\n      \r\n    },\r\n    sendWebSocketMessage() {\r\n      // Отправка сообщения через WebSocket\r\n      if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n        this.socket.send(this.wsMessage);\r\n        console.log('Отправлено сообщение через WebSocket:', this.wsMessage);\r\n       this.wsMessages.push(this.wsMessage) \r\n        this.wsMessage = ''; // Очищаем поле ввода сообщения\r\n      } else {\r\n        console.error('WebSocket соединение не установлено или закрыто.');\r\n      }\r\n    },\r\n    filteredKeywords() {\r\n      const searchTerm = this.searchKeyword.toLowerCase();\r\n      return this.keywords.filter(keyword => keyword.toLowerCase().includes(searchTerm));\r\n  },\r\n  },\r\n};\r\n</script>\r\n"],"mappings":";gCAKMA,mBAAA,CAAoD;EAA5CC,IAAI,EAAC;AAAQ,GAAC,uBAAqB;gCAK7CD,mBAAA,CAAwB,YAApB,iBAAe;gCAQjBA,mBAAA,CAAkC,YAA9B,2BAAyB;gCAO7BA,mBAAA,CAA0B,YAAtB,mBAAiB;;;uBAxBzBE,mBAAA,CAgCM,cA/BJC,mBAAA,sCAAyC,EACzCH,mBAAA,CAGO;IAHAI,QAAM,EAAAC,MAAA,QAAAA,MAAA,MAAAC,cAAA,KAAAC,IAAA,KAAUC,QAAA,CAAAC,eAAA,IAAAD,QAAA,CAAAC,eAAA,IAAAF,IAAA,CAAe;sBACpCP,mBAAA,CAAmD;+DAAnCU,KAAA,CAAAC,GAAG,GAAAC,MAAA;IAAEX,IAAI,EAAC,MAAM;IAACY,WAAW,EAAC;iDAA7BH,KAAA,CAAAC,GAAG,E,GACnBG,UAAoD,C,4BAEtDX,mBAAA,qCAAwC,EAExCA,mBAAA,qBAAwB,EACxBY,UAAwB,E,gBACtBf,mBAAA,CAAkF;+DAAlEU,KAAA,CAAAM,aAAa,GAAAJ,MAAA;IAAEX,IAAI,EAAC,MAAM;IAACY,WAAW,EAAC;iDAAvCH,KAAA,CAAAM,aAAa,E,GAC7BhB,mBAAA,CAEK,c,kBADHE,mBAAA,CAAgFe,SAAA,QAAAC,WAAA,CAAjDV,QAAA,CAAAW,gBAAgB,GAAnCC,OAAO,EAAEC,KAAK;yBAA1BnB,mBAAA,CAAgF;MAA9BoB,GAAG,EAAED;IAAK,GAAAE,gBAAA,CAAKH,OAAO;oCAE5EpB,mBAAA,CAOM,cAJJwB,UAAkC,G,kBAClCtB,mBAAA,CAEMe,SAAA,QAAAC,WAAA,CAF2BR,KAAA,CAAAe,aAAa,GAAjCC,QAAQ,EAAEL,KAAK;yBAA5BnB,mBAAA,CAEM;MAF2CoB,GAAG,EAAED;IAAK,IACzDrB,mBAAA,CAAqB,WAAAuB,gBAAA,CAAfG,QAAQ,iB;oCAGlBvB,mBAAA,sBAAyB,EACzBH,mBAAA,CAQM,cAPJ2B,UAA0B,E,gBAC1B3B,mBAAA,CAAyE;+DAAzDU,KAAA,CAAAkB,SAAS,GAAAhB,MAAA;IAAEX,IAAI,EAAC,MAAM;IAACY,WAAW,EAAC;iDAAnCH,KAAA,CAAAkB,SAAS,E,GACzB5B,mBAAA,CAA4E;IAAnE6B,OAAK,EAAAxB,MAAA,QAAAA,MAAA,UAAAE,IAAA,KAAEC,QAAA,CAAAsB,oBAAA,IAAAtB,QAAA,CAAAsB,oBAAA,IAAAvB,IAAA,CAAoB;KAAE,+BAA6B,I,kBACnEL,mBAAA,CAGMe,SAAA,QAAAC,WAAA,CAH0BR,KAAA,CAAAqB,UAAU,GAA7BC,OAAO,EAAEX,KAAK;yBAA3BnB,mBAAA,CAGM;MAHuCoB,GAAG,EAAED;IAAK,IACrDrB,mBAAA,CAAoB,WAAAuB,gBAAA,CAAdS,OAAO,iB"},"metadata":{},"sourceType":"module","externalDependencies":[]}