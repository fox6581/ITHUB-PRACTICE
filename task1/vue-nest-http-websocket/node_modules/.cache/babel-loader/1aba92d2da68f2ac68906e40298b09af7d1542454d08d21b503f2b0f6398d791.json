{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ref, onMounted } from 'vue';\nimport VueNativeSock from 'vue-native-websocket';\nexport default {\n  setup() {\n    const url = ref('http://localhost:3000/api');\n    const httpResponses = ref([]);\n    const wsMessage = ref('');\n    const wsMessages = ref([]);\n    const selectedKeyword = ref('');\n    const selectedUrls = ref([]);\n    const socket = ref(null);\n\n    // Инициализация WebSocket и обработчика ошибок\n    const initWebSocket = () => {\n      socket.value = new WebSocket('ws://localhost:3000/api');\n\n      // Обработчик ошибок WebSocket\n      socket.value.addEventListener('error', event => {\n        console.error('Произошла ошибка:', event);\n      });\n\n      // Обработчик события открытия соединения\n      socket.value.addEventListener('open', event => {\n        console.log('WebSocket соединение установлено:', event);\n      });\n\n      // Обработчик события приема сообщения\n      socket.value.addEventListener('message', event => {\n        console.log('Получено сообщение:', event.data);\n        wsMessages.value.push(event.data); // Сохраняем полученное сообщение\n      });\n\n      // Обработчик события закрытия соединения\n      socket.value.addEventListener('close', event => {\n        console.log('WebSocket соединение закрыто:', event);\n      });\n    };\n    const sendWebSocketMessage = () => {\n      // Отправка сообщения через WebSocket\n      if (socket.value && socket.value.readyState === WebSocket.OPEN) {\n        socket.value.send(wsMessage.value);\n        console.log('Отправлено сообщение через WebSocket:', wsMessage.value);\n        wsMessages.value.push(wsMessage.value);\n        wsMessage.value = ''; // Очищаем поле ввода сообщения\n      } else {\n        console.error('WebSocket соединение не установлено или закрыто.');\n      }\n    };\n    const sendHttpRequest = async () => {\n      try {\n        const response = await fetch(url.value);\n        const data = await response.text();\n        httpResponses.value.push(data);\n      } catch (error) {\n        console.error(error);\n      }\n    };\n    const updateUrl = () => {\n      socket.value.sendObj({\n        keyword: selectedKeyword.value\n      });\n    };\n\n    // Инициализация WebSocket при создании компонента\n    onMounted(initWebSocket);\n    return {\n      url,\n      httpResponses,\n      wsMessage,\n      wsMessages,\n      selectedKeyword,\n      selectedUrls,\n      sendHttpRequest,\n      sendWebSocketMessage,\n      updateUrl\n    };\n  }\n};","map":{"version":3,"names":["ref","onMounted","VueNativeSock","setup","url","httpResponses","wsMessage","wsMessages","selectedKeyword","selectedUrls","socket","initWebSocket","value","WebSocket","addEventListener","event","console","error","log","data","push","sendWebSocketMessage","readyState","OPEN","send","sendHttpRequest","response","fetch","text","updateUrl","sendObj","keyword"],"sources":["C:\\std\\vue-nest-http-websocket\\src\\components\\HttpClient.vue"],"sourcesContent":["<template>\r\n  <div>\r\n    <!-- Форма для отправки HTTP-запросов -->\r\n    <form @submit.prevent=\"sendHttpRequest\">\r\n      <input v-model=\"url\" type=\"text\" placeholder=\"URL\">\r\n      <button type=\"submit\">Отправить HTTP-запрос</button>\r\n    </form>\r\n\r\n    <!-- Поиск через сокеты -->\r\n    <div>\r\n      <h2>Поиск через сокеты</h2>\r\n      <input v-model=\"selectedKeyword\" @input=\"updateUrl\" placeholder=\"Введите ключевое слово\" />\r\n      <p v-if=\"selectedUrls.length > 0\">\r\n        Соответствующие URL-адреса:\r\n        <ul>\r\n          <li v-for=\"(url, index) in selectedUrls\" :key=\"index\">\r\n            <a :href=\"'http://' + url\">{{ url }}</a>\r\n          </li>\r\n        </ul>\r\n      </p>\r\n    </div>\r\n\r\n    <!-- Результаты HTTP-запросов -->\r\n    <h2>Результаты HTTP-запросов:</h2>\r\n    <div v-for=\"(response, index) in httpResponses\" :key=\"index\">\r\n      <p>{{ response }}</p>\r\n    </div>\r\n\r\n    <!-- WebSocket-клиент -->\r\n    <div>\r\n      <h2>WebSocket-клиент:</h2>\r\n      <input v-model=\"wsMessage\" type=\"text\" placeholder=\"WebSocket сообщение\">\r\n      <button @click=\"sendWebSocketMessage\">Отправить WebSocket сообщение</button>\r\n      <div v-for=\"(message, index) in wsMessages\" :key=\"index\">\r\n        <p>{{ message }}</p>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { ref, onMounted } from 'vue';\r\nimport VueNativeSock from 'vue-native-websocket';\r\n\r\nexport default {\r\n  setup() {\r\n    const url = ref('http://localhost:3000/api');\r\n    const httpResponses = ref([]);\r\n    const wsMessage = ref('');\r\n    const wsMessages = ref([]);\r\n    const selectedKeyword = ref('');\r\n    const selectedUrls = ref([]);\r\n\r\n    const socket = ref(null);\r\n\r\n    // Инициализация WebSocket и обработчика ошибок\r\n    const initWebSocket = () => {\r\n      socket.value = new WebSocket('ws://localhost:3000/api');\r\n\r\n      // Обработчик ошибок WebSocket\r\n      socket.value.addEventListener('error', (event) => {\r\n        console.error('Произошла ошибка:', event);\r\n      });\r\n\r\n      // Обработчик события открытия соединения\r\n      socket.value.addEventListener('open', (event) => {\r\n        console.log('WebSocket соединение установлено:', event);\r\n      });\r\n\r\n      // Обработчик события приема сообщения\r\n      socket.value.addEventListener('message', (event) => {\r\n        console.log('Получено сообщение:', event.data);\r\n        wsMessages.value.push(event.data); // Сохраняем полученное сообщение\r\n      });\r\n\r\n      // Обработчик события закрытия соединения\r\n      socket.value.addEventListener('close', (event) => {\r\n        console.log('WebSocket соединение закрыто:', event);\r\n      });\r\n    };\r\n\r\n    const sendWebSocketMessage = () => {\r\n      // Отправка сообщения через WebSocket\r\n      if (socket.value && socket.value.readyState === WebSocket.OPEN) {\r\n        socket.value.send(wsMessage.value);\r\n        console.log('Отправлено сообщение через WebSocket:', wsMessage.value);\r\n        wsMessages.value.push(wsMessage.value);\r\n        wsMessage.value = ''; // Очищаем поле ввода сообщения\r\n      } else {\r\n        console.error('WebSocket соединение не установлено или закрыто.');\r\n      }\r\n    };\r\n\r\n    const sendHttpRequest = async () => {\r\n      try {\r\n        const response = await fetch(url.value);\r\n        const data = await response.text();\r\n        httpResponses.value.push(data);\r\n      } catch (error) {\r\n        console.error(error);\r\n      }\r\n    };\r\n\r\n    const updateUrl = () => {\r\n      socket.value.sendObj({ keyword: selectedKeyword.value });\r\n    };\r\n\r\n    // Инициализация WebSocket при создании компонента\r\n    onMounted(initWebSocket);\r\n\r\n    return {\r\n      url,\r\n      httpResponses,\r\n      wsMessage,\r\n      wsMessages,\r\n      selectedKeyword,\r\n      selectedUrls,\r\n      sendHttpRequest,\r\n      sendWebSocketMessage,\r\n      updateUrl,\r\n    };\r\n  },\r\n};\r\n</script>\r\n\r\n<style lang=\"scss\">\r\nul {\r\n  list-style: none;\r\n}\r\n</style>\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}